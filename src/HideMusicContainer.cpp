/*
 * ============================================================================
 *  Name     : CHideMusicContainer from HideMusicContainer.h
 *  Part of  : HideMusic
 *  Created  : 04/04/2005 by Sergio Padrino Recio
 *  Implementation notes:
 *     Initial content was generated by Series 60 AppWizard.
 *  Version  :
 *  Copyright: No hay xD
 * ============================================================================
 */

// INCLUDE FILES
#include "HideMusicContainer.h"

#include <eikclb.h>				//column listbox
#include <eikclbd.h>			//listbox columndata
#include <aknlists.h>			//aknlist xDDD
#include <f32file.h>			//funciones de archivo
#include <akniconarray.h> //array de iconos

// ================= MEMBER FUNCTIONS =======================

// ---------------------------------------------------------
// CHideMusicContainer::ConstructL(const TRect& aRect)
// EPOC two phased constructor
// ---------------------------------------------------------
//
void CHideMusicContainer::ConstructL(const TRect &aRect)
{
	CreateWindowL();

	iDirList = new (ELeave) CAknSingleGraphicStyleListBox;
	iDirList->ConstructL(this, EAknListBoxMultiselectionList);
	iDirList->SetContainerWindowL(*this);
	iDirList->CreateScrollBarFrameL(ETrue);
	iDirList->ScrollBarFrame()->SetScrollBarVisibilityL(CEikScrollBarFrame::EOn, CEikScrollBarFrame::EAuto);

	CArrayPtr<CGulIcon> *iconList = new (ELeave) CAknIconArray(3);
	CleanupStack::PushL(iconList);
	iconList->AppendL(iEikonEnv->CreateIconL(_L("\\system\\apps\\hidemusic\\checked.mbm"), 0, 1));
	iconList->AppendL(iEikonEnv->CreateIconL(_L("\\system\\apps\\hidemusic\\checked.mbm"), 2, 3));
	iDirList->ItemDrawer()->ColumnData()->SetIconArray(iconList);
	CleanupStack::Pop();

	CDesCArray *itemList = new (ELeave) CDesCArrayFlat(3);
	TBuf<255> item;
	_LIT(KListItemFormat, "1\t%S\t\t");
	RFs aFs;
	aFs.Connect();
	CDirScan *MusicDir = CDirScan::NewL(aFs);
	_LIT(KDirText, "e:\\music\\");
	MusicDir->SetScanDataL(KDirText, KEntryAttDir | KEntryAttHidden | KEntryAttMatchExclusive, ESortByName | EAscending, CDirScan::EScanDownTree);
	CDir *currentDir = NULL;
	// if(fileMan->Attribs(_L("z:\\music\\"),NULL,NULL, TTime())!=KErrNone)

	TRAPD(error, MusicDir->NextL(currentDir));
	if (!(error || !currentDir))
	{
		CArrayFixFlat<TInt> *selectionArray = new CArrayFixFlat<TInt>(currentDir->Count());
		CleanupStack::PushL(selectionArray);

		for (TInt contador = 0; contador < currentDir->Count(); contador++)
		{
			if (!((*currentDir)[contador].iAtt & KEntryAttHidden))
			{
				selectionArray->AppendL(contador);
			}

			item.Format(KListItemFormat, &(*currentDir)[contador].iName); //&itemText);
			itemList->AppendL(item);
		}

		iDirList->Model()->SetItemTextArray(itemList);
		iDirList->Model()->SetOwnershipType(ELbmOwnsItemArray);

		iDirList->SetSelectionIndexesL(selectionArray);
		CleanupStack::PopAndDestroy(); // Array

		iDirList->HandleItemAdditionL();
	}

	iAvkonAppUi->AddToStackL(iDirList);

	aFs.Close();

	SetRect(aRect);
	ActivateL();
}

void CHideMusicContainer::MarkAllDirs()
{
	CArrayFixFlat<TInt> *selectionArray = new CArrayFixFlat<TInt>(iDirList->Model()->NumberOfItems());
	CleanupStack::PushL(selectionArray);

	for (TInt contador = 0; contador < iDirList->Model()->NumberOfItems(); contador++)
		selectionArray->AppendL(contador);

	iDirList->SetSelectionIndexesL(selectionArray);

	CleanupStack::PopAndDestroy(); // Array
}

void CHideMusicContainer::UnmarkAllDirs()
{
	iDirList->ClearSelection();
}

void CHideMusicContainer::InvertSelection()
{
	const CArrayFix<TInt> *selectionArray = iDirList->SelectionIndexes();
	TBool visibleDirs[255];
	for (TInt contador = 0; contador <= 255; contador++)
	{
		visibleDirs[contador] = 1;
	}
	for (contador = 0; contador < selectionArray->Count(); contador++)
	{
		visibleDirs[(*selectionArray)[contador]] = 0;
	}

	CArrayFixFlat<TInt> *newSelectionArray = new CArrayFixFlat<TInt>(iDirList->Model()->NumberOfItems());
	CleanupStack::PushL(newSelectionArray);
	for (contador = 0; contador < iDirList->Model()->NumberOfItems(); contador++)
	{
		// visibleDirs[contador]= 1 - visibleDirs[contador];
		if (visibleDirs[contador] == 1)
			newSelectionArray->AppendL(contador);
	}
	iDirList->SetSelectionIndexesL(newSelectionArray);

	CleanupStack::PopAndDestroy(); // Array
}

void CHideMusicContainer::HideUnmarkedDirs()
{
	RFs aFs;
	aFs.Connect();
	CDirScan *MusicDir = CDirScan::NewL(aFs);
	_LIT(KDirText, "e:\\music\\");
	TBuf<255> dirPath;
	MusicDir->SetScanDataL(KDirText, KEntryAttDir | KEntryAttHidden | KEntryAttMatchExclusive, ESortByName | EAscending, CDirScan::EScanDownTree);
	CDir *currentDir = NULL;
	TInt contador = 0;

	TRAPD(error, MusicDir->NextL(currentDir));
	if (!(error || !currentDir))
	{
		const CArrayFix<TInt> *selectionArray = iDirList->SelectionIndexes();
		TBool visibleDirs[255];
		for (contador = 0; contador <= 255; contador++)
		{
			visibleDirs[contador] = 0;
		}
		for (contador = 0; contador < selectionArray->Count(); contador++)
		{
			visibleDirs[(*selectionArray)[contador]] = ETrue;
		}

		for (int contador = 0; contador < iDirList->Model()->NumberOfItems(); contador++)
		{
			dirPath.Format(_L("e:\\music\\%S"), &(*currentDir)[contador].iName);
			if (visibleDirs[contador] == 1)
				aFs.SetAtt(dirPath, KEntryAttDir | KEntryAttNormal, KEntryAttHidden);
			else
				aFs.SetAtt(dirPath, KEntryAttHidden | KEntryAttDir, NULL);
		}
	}
	aFs.Close();
}

// Destructor
CHideMusicContainer::~CHideMusicContainer()
{

	delete iDirList;
}

// ---------------------------------------------------------
// CHideMusicContainer::SizeChanged()
// Called by framework when the view size is changed
// ---------------------------------------------------------
//
void CHideMusicContainer::SizeChanged()
{
	// TODO: Add here control resize code etc.
	iDirList->SetExtent(TPoint(0, 0), Size());
}

// ---------------------------------------------------------
// CHideMusicContainer::CountComponentControls() const
// ---------------------------------------------------------
//
TInt CHideMusicContainer::CountComponentControls() const
{
	return 1; // return nbr of controls inside this container
}

// ---------------------------------------------------------
// CHideMusicContainer::ComponentControl(TInt aIndex) const
// ---------------------------------------------------------
//
CCoeControl *CHideMusicContainer::ComponentControl(TInt aIndex) const
{
	switch (aIndex)
	{
	case 0:
		return iDirList;
	default:
		return NULL;
	}
}

// ---------------------------------------------------------
// CHideMusicContainer::Draw(const TRect& aRect) const
// ---------------------------------------------------------
//
void CHideMusicContainer::Draw(const TRect &aRect) const
{
	CWindowGc &gc = SystemGc();
	// TODO: Add your drawing code here
	// example code...
	gc.SetPenStyle(CGraphicsContext::ENullPen);
	gc.SetBrushColor(KRgbGray);
	gc.SetBrushStyle(CGraphicsContext::ESolidBrush);
	gc.DrawRect(aRect);
}

// ---------------------------------------------------------
// CHideMusicContainer::HandleControlEventL(
//     CCoeControl* aControl,TCoeEvent aEventType)
// ---------------------------------------------------------
//
void CHideMusicContainer::HandleControlEventL(
		CCoeControl * /*aControl*/, TCoeEvent /*aEventType*/)
{
	// TODO: Add your control event handler code here
}

// End of File
